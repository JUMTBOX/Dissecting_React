## 7. JavaScript Design Pattern

## 생성 패턴

### 생성자 패턴 
- Car class 의 constructor function 을 통해 instantiate 한 객체들이 공통적으로 사용할 수 있게 
Car.prototype 에 메서드 정의해서 사용하는 방식을 설명

### 모듈 패턴
- 객체 리터럴 선언
- IIFE(Immediately Invoked Function Expression; 즉시실행함수)로 반환하는 객체를 사용하는 패턴
- 클로저와 스코프로 private(접근제한자) 키워드 대체 

```jsx
let counter = 0;

const testModule = {
    incrementCounter() {
        return counter++;
    },
    resetCounter() {
        console.log(`counter value prior to reset: ${counter}`);
        counter = 0;
    }
}
export default testModule;
```
```jsx
import testModule from "./testModule";

testModule.incrementCounter();

testModule.resetCounter();
```
- WeakMap을 사용하는 최신 모듈 패턴
- WeakMap 객체는 약한 참조를 가진 키-값 쌍으로 이루어진 집합체, 키는 객체여야만 하나, 값은 상관 없다.

```jsx
let _counter = new WeakMap();

class Module {
    constructor() {
        _counter.set(this, 0);
    }
    
    incrementCounter() {
        let counter = _counter.get(this);
        counter++;
        _counter.set(this, counter);
    }
    
    resetCounter() {
        console.log(`counter value prior to reset: ${_counter.get(this)}`);
        _counter.set(this, 0);
    }
}
```
### 싱글톤 패턴 
- 모듈 스코프에서만 접근 가능한 instance 변수를 하나 만들고 싱글톤으로 관리하고 싶은 class 의 생성자 내부에서 instance 변수 값이 존재하면 해당 변수 값을 return 하고
  instance 변수 값이 없다면 instance 변수 값을 this 로 할당.. 

### 프로토타입 패턴
- GOF는 프로토타입 패턴을 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴이라고 정의함
- 상속을 구현하는 쉬운 방법일 뿐만 아니라 성능에서의 이점도 챙길 수 있다.
<br/> 객체 내의 함수(메서드)를 정의할 때 복사본이 아닌 참조로 생성되어 모든 자식 객체가 동일한 함수를 가리키게 할 수 있기 때문이다.
- ES5 표준에 따라 프로토타입의 상속은 Object.create를 필요로 한다.
- 다시 말해 Object.create 메서드 사용을 통해 프로토타입 객체를 생성하고 특정 속성을 추가 할 수도 있다.

#### Object.create 

```jsx
const myCar = {
    name: "Ford Escort",
    
    drive() {
        console.log("Weeee, I'm driving!");
    },
    
    panic() {
        console.log("Wait, How do you stop this thing?");
    },
};

const yourCar = Object.create(myCar);

console.log(yourCar.name);  // "Ford Escort"
```
- Object.create는 다른 객체로부터 직접 상속할 수 있게 해주는 차등 상속(differential inheritance)와 같은 고급 개념을 쉽게 구현할 수 있게 해준다.
- 두 번째 인자를 사용하여 객체의 속성을 초기화 할 수 있게 해준다. 
- 객체의 속성을 나열(enumeration)할 때 문제를 일으킬 수 있으므로, Object.prototype.hasOwnProperty로 검사하는 것을 추천

```jsx
const vehicle = {
    getModel () {
        console.log(`The model of this vehicle is...${this.model}`);
    }
};

const car = Object.create(vehicle, {
    id:{
        value: My_GLOBAL.nextId(),
        // writable: false, configurable: false 가 기본값으로 들어간다.
        enumerable: true,
    },
    model: {
        value: "Ford",
        enumerable: true,
    }
});
```
- Object.create를 사용하지 않고 프로토타입 패턴을 구현하고 싶다면 class syntax - extends 키워드를 사용할 것...
- 하지만 이 방식으로는 읽기 전용 속성을 사용할 수 없음 (writable 속성의 값을 false로 설정할 수 없으니까..)

- 또 다른 프로토타입 패턴의 구현
```jsx
const beget = (() => {
    class F {
        constructor() {}
    }
    
    return (proto) => {
        F.prototype = proto;
        return new F();
    }
})();
```

### 팩토리 패턴
- 다른 패턴과 달리 생성자를 필요로하지 않지만, 필요한 타입의 팩토리 객체를 생성하는 다른 방법을 제공한다.
- 동적인 요소나 Application 구조에 깊게 의지하는 등의 상황처럼 객체 생성 과정이 복잡한 경우 유용하다.

```jsx
class Car {
    constructor({doors=4, state = "brand new", color="silver"}={}) {
        this.doors = doors;
        this.state = state;
        this.color = color;
    }
}

class Truck {
    constructor({ state = "used", wheelsize = "large", color="silver"} = {}) {
        this.state = state;
        this.wheelsize = wheelsize;
        this.color = color;    
    }
}

class VehicleFactory {
    constructor() {
        this.vehicleClass = Car;
    }
    
    createVehicle({ vehicleType, ...rest }) {
        switch(vehicleType) {
            case "car":
                this.vehicleClass = Car;
                break;
            case "truck":
                this.vehicleClass = Truck;
                break;
            default:
                // 해당되지 않으면 VehicleFactory.prototype.vehicleClass에 Car를 할당(?)
                break;                    
        }
        return new this.vehicleClass(rest);
    }
}

// use case
const carFactory = new VehicleFactory();

const car = carFactory.createVehicle({
    vehicleType: "car",
    color: "yellow",
    doors: 6,
});

console.log(car instanceof Car);  // true
console.log(car); // { vehicleType: "car", color: "yellow", doors: 6 }
```
- 서브클래스화 하여 새로운 팩토리 생성 가능..
```jsx
class TruckFactory extends VehicleFactory {
    constructor() {
        super();
        this.vehicleClass = Truck;    
    }
}
```
- <팩토리 패턴>을 사용하기 좋은 상황
  - 객체나 컴포넌트의 생성 과정이 높은 복잡성을 가지고 있을 때
  - 상황에 맞춰 다양한 객체 인스턴스를 편리하게 생성할 수 있는 방법이 필요할 때
  - 같은 속성을 공유하는 여러 개의 작은 객체 또는 컴포넌트를 다뤄야 할 때
  - 덕 타이핑 같은 API 규칙만 충족하면 되는 다른 객체의 인스턴스와 함께 객체를 구성할 때, 또한 디커플링에도 유용..

- <팩토리 패턴>을 사용하면 안 되는 상황
  - 객체 생성 인터페이스 제공이 작업 중인 라이브러리나 프레임워크의 설계 목표가 아니라면 차라리 생성자를 사용하는 것이 좋다.
  - 객체 생성 과정을 인터페이스 뒤에 추상화하기 때문에 객체 생성 과정이 복잡할 경우 단위 테스트의 복잡성 또한 증가할 수 있음 