## 7. JavaScript Design Pattern

## 생성 패턴

### 생성자 패턴 
- Car class 의 constructor function 을 통해 instantiate 한 객체들이 공통적으로 사용할 수 있게 
Car.prototype 에 메서드 정의해서 사용하는 방식을 설명

### 모듈 패턴
- 객체 리터럴 선언
- IIFE(Immediately Invoked Function Expression; 즉시실행함수)로 반환하는 객체를 사용하는 패턴
- 클로저와 스코프로 private(접근제한자) 키워드 대체 

```jsx
let counter = 0;

const testModule = {
    incrementCounter() {
        return counter++;
    },
    resetCounter() {
        console.log(`counter value prior to reset: ${counter}`);
        counter = 0;
    }
}
export default testModule;
```
```jsx
import testModule from "./testModule";

testModule.incrementCounter();

testModule.resetCounter();
```
- WeakMap을 사용하는 최신 모듈 패턴
- WeakMap 객체는 약한 참조를 가진 키-값 쌍으로 이루어진 집합체, 키는 객체여야만 하나, 값은 상관 없다.

```jsx
let _counter = new WeakMap();

class Module {
    constructor() {
        _counter.set(this, 0);
    }
    
    incrementCounter() {
        let counter = _counter.get(this);
        counter++;
        _counter.set(this, counter);
    }
    
    resetCounter() {
        console.log(`counter value prior to reset: ${_counter.get(this)}`);
        _counter.set(this, 0);
    }
}
```
### 싱글톤 패턴 
- 모듈 스코프에서만 접근 가능한 instance 변수를 하나 만들고 싱글톤으로 관리하고 싶은 class 의 생성자 내부에서 instance 변수 값이 존재하면 해당 변수 값을 return 하고
  instance 변수 값이 없다면 instance 변수 값을 this 로 할당.. 

### 프로토타입 패턴
- GOF는 프로토타입 패턴을 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴이라고 정의함
- 상속을 구현하는 쉬운 방법일 뿐만 아니라 성능에서의 이점도 챙길 수 있다.
<br/> 객체 내의 함수(메서드)를 정의할 때 복사본이 아닌 참조로 생성되어 모든 자식 객체가 동일한 함수를 가리키게 할 수 있기 때문이다.
- ES5 표준에 따라 프로토타입의 상속은 Object.create를 필요로 한다.
- 다시 말해 Object.create 메서드 사용을 통해 프로토타입 객체를 생성하고 특정 속성을 추가 할 수도 있다.

#### Object.create 

```jsx
const myCar = {
    name: "Ford Escort",
    
    drive() {
        console.log("Weeee, I'm driving!");
    },
    
    panic() {
        console.log("Wait, How do you stop this thing?");
    },
};

const yourCar = Object.create(myCar);

console.log(yourCar.name);  // "Ford Escort"
```
- Object.create는 다른 객체로부터 직접 상속할 수 있게 해주는 차등 상속(differential inheritance)와 같은 고급 개념을 쉽게 구현할 수 있게 해준다.
- 두 번째 인자를 사용하여 객체의 속성을 초기화 할 수 있게 해준다. 
- 객체의 속성을 나열(enumeration)할 때 문제를 일으킬 수 있으므로, Object.prototype.hasOwnProperty로 검사하는 것을 추천

```jsx
const vehicle = {
    getModel () {
        console.log(`The model of this vehicle is...${this.model}`);
    }
};

const car = Object.create(vehicle, {
    id:{
        value: My_GLOBAL.nextId(),
        // writable: false, configurable: false 가 기본값으로 들어간다.
        enumerable: true,
    },
    model: {
        value: "Ford",
        enumerable: true,
    }
});
```
- Object.create를 사용하지 않고 프로토타입 패턴을 구현하고 싶다면 class syntax - extends 키워드를 사용할 것...
- 하지만 이 방식으로는 읽기 전용 속성을 사용할 수 없음 (writable 속성의 값을 false로 설정할 수 없으니까..)

- 또 다른 프로토타입 패턴의 구현
```jsx
const beget = (() => {
    class F {
        constructor() {}
    }
    
    return (proto) => {
        F.prototype = proto;
        return new F();
    }
})();
```

### 팩토리 패턴
- 다른 패턴과 달리 생성자를 필요로하지 않지만, 필요한 타입의 팩토리 객체를 생성하는 다른 방법을 제공한다.
- 동적인 요소나 Application 구조에 깊게 의지하는 등의 상황처럼 객체 생성 과정이 복잡한 경우 유용하다.

```jsx
class Car {
    constructor({doors=4, state = "brand new", color="silver"}={}) {
        this.doors = doors;
        this.state = state;
        this.color = color;
    }
}

class Truck {
    constructor({ state = "used", wheelsize = "large", color="silver"} = {}) {
        this.state = state;
        this.wheelsize = wheelsize;
        this.color = color;    
    }
}

class VehicleFactory {
    constructor() {
        this.vehicleClass = Car;
    }
    
    createVehicle({ vehicleType, ...rest }) {
        switch(vehicleType) {
            case "car":
                this.vehicleClass = Car;
                break;
            case "truck":
                this.vehicleClass = Truck;
                break;
            default:
                // 해당되지 않으면 VehicleFactory.prototype.vehicleClass에 Car를 할당(?)
                break;                    
        }
        return new this.vehicleClass(rest);
    }
}

// use case
const carFactory = new VehicleFactory();

const car = carFactory.createVehicle({
    vehicleType: "car",
    color: "yellow",
    doors: 6,
});

console.log(car instanceof Car);  // true
console.log(car); // { vehicleType: "car", color: "yellow", doors: 6 }
```
- 서브클래스화 하여 새로운 팩토리 생성 가능..
```jsx
class TruckFactory extends VehicleFactory {
    constructor() {
        super();
        this.vehicleClass = Truck;    
    }
}
```
- <팩토리 패턴>을 사용하기 좋은 상황
  - 객체나 컴포넌트의 생성 과정이 높은 복잡성을 가지고 있을 때
  - 상황에 맞춰 다양한 객체 인스턴스를 편리하게 생성할 수 있는 방법이 필요할 때
  - 같은 속성을 공유하는 여러 개의 작은 객체 또는 컴포넌트를 다뤄야 할 때
  - 덕 타이핑 같은 API 규칙만 충족하면 되는 다른 객체의 인스턴스와 함께 객체를 구성할 때, 또한 디커플링에도 유용..

- <팩토리 패턴>을 사용하면 안 되는 상황
  - 객체 생성 인터페이스 제공이 작업 중인 라이브러리나 프레임워크의 설계 목표가 아니라면 차라리 생성자를 사용하는 것이 좋다.
  - 객체 생성 과정을 인터페이스 뒤에 추상화하기 때문에 객체 생성 과정이 복잡할 경우 단위 테스트의 복잡성 또한 증가할 수 있음

## 구조 패턴
- 클래스와 객체를 체계적으로 구성하는 방법을 다룬다.

### 퍼사드 패턴
- 퍼사드(Facade)란 실제 모습을 숨기고 꾸며낸 겉모습만을 세상에 드러내는 것을 뜻한다.
- jQuery 같은 자바스크립트 라이브러리에서 쉽게 볼 수 있는 구조 패턴이다. 
  <br/> 광범위한 기능 구현을 가지고 있으면서도 제한된 추상화 메서드만이 공개되어 사용할 수 있도록 한다.

- 브라우저 환경의 이벤트를 수신하는 인터페이스를 퍼사드 패턴으로 간소화 하는 예제
```jsx
const addMyEvent = (element, event, handlerFunction) => {
    if(element.addEventListener) {
        element.addEventListener(event, handlerFunction, false);
    } else if (element.attachEvent) {
        element.attachEvent(`on${event}`, handlerFunction);
    } else {
        element[`on${event}`] = handlerFunction;
    }
}
```
- 퍼사트 패턴과 모듈 패턴을 합성 가능


### 서브클래싱 
- 부모 클래스를 확장하는 자식 클래스를 서브클래스라고 부른다. (ES2015+ 의 class syntax와 extends, super 키워드 활용) 

### 믹스인 패턴
- C++ 나 Lisp 같은 전통적인 프로그래밍 언어에서 서브클래스가 쉽게 상속받아 기능을 재사용할 수 있도록 하는 클래스를 뜻함
- JS에서는 기능의 확장을 위해 믹스인의 상속을 이용한다.
- JS의 class는 부모class를 하나만 가질 수 있지만 여러 class의 기능을 섞는 것으로 문제를 해결할 수 있다.

- 유틸리티 함수를 포함하는 믹스인 예제
```jsx
const MyMixins = (superClass) => 
    class extends superclass {
        constructor() {}
        
        moveUp() {
            console.log("move up");
        }
        moveDown() {
            console.log("move down");
        }
        stop() {
            console.log("stop! in the name of love!");
        }        
    }

```

```jsx
class CarAnimator {
    moveLeft() {
        console.log("move left");
    }
}

class PersonAnimator {
    moveRandomly() {
        /* ... */
    }
}

/* MyMixins를 활용하여 CarAnimator 확장 */
class MyAnimator extends MyMixins(CarAnimator) {
    constructor() {}
}

const myAnimator = new MyAnimator();
myAnimator.moveLeft();
myAnimator.moveDown();
myAnimator.stop(); 
```
- <믹스인 패턴> 장점과 단점
  - 객체 인스턴스 사이에 공유되는 기능이 있다면 믹스인을 통해 기능을 공유하여 중복을 피하고 고유 기능을 구현하는 데에 집중할 수 있다.
  - 일부 개발자들은 클래스나 객체의 프로토타입에 기능을 주입하는 것을 프로토타입 오염과 함수 출처에 대한 불확실성을 초래하기 때문에 나쁜 방법이라고 여긴다.
  - React에서도 ES6 클래스 도입 이전에는 컴포넌트에 기능을 추가하기 위해 믹스인을 사용하였으나, 컴포넌트의 유지보수와 재사용을 복잡하게 만든다는 이유로 철회

### 데코레이터 패턴
- 코드 재사용을 목표로 하는 구조 패턴, 믹스인과 마찬가지로 객체 서브클래싱의 또 다른 방법
- 기본적으로 데코레이터는 기존 클래스에 동적으로 기능을 추가하기 위해 사용

- 데코레이터 예제
```jsx
class Vehicle {
    constructor(vehicleType) {
        this.vehicleType = vehicleType || "car";
        this.model = "default";
        this.license = "0000-000";
    }
}

const tetsInstance = new Vehicle("car");
console.log(tetsInstance);

/* 데코레이트 될 새로운 차량 인스턴스 */
const truck = new Vehicle("truck");

/** 
* 여기서 setter에 화살표 함수를 사용하지 않은 이유는 함수 몸체에서 사용하는 this 값의 바인딩 때문이다... 
* #더 알아보기 참조..
*/ 
truck.setModel = function(modelName) {
    this.model = modelName;
};

truck.setColor = function(color) {
    this.color = color;
};

truck.setModel("CAT");
truck.setColor("blue");

// Vehicle class가 변경되지 않았음을 확인
const secondeInstance = new Vehicle("car");
console.log(secondeInstance);
```
### 의사 클래스 데코레이터
- [Pro JavaScript Design Pattern](Apress, 2007)에서는 데코레이터 패턴을 같은 인터페이스를 가진 서로 다른 객체 내부에 새 객체를 넣어서 사용하는 방법이라고 설명한다.
- 인터페이스란 객체가 <b>가져야 할</b> 메서드를 정의하는 방법이지만 메서드를 어떻게 구현해야 하는지는 명시하지 않는다.
- 다른 언어와 같은 인터페이스를 제공하는 JS 표준 API는 없기 때문에 TypeScript를 활용하는 것이 좋다.

### 추상 데코레이터 (생략)
- <데코레이터 패턴>의 장점과 단점
    - 새로운 기능으로 감싸져 확장되거나 '데코레이트'될 수 있으며 베이스 객체가 변경될 걱정 없이 사용할 수 있다.
    - 네임 스페이스에 작고 비슷한 객체를 추가하기 때문에, 잘 관리하지 않는다면 application의 구조를 무척 복잡하게 만들 수도 있다.
    - 또한 이 패턴에 익숙하지 않은 다른 개발자가 패턴의 사용 목적을 파악하기 어렵게 되어 관리가 힘들어질 수 있다.

### 플라이웨이트 패턴
- 반복되고 느리고 비효율적으로 데이터를 공유하는 코드를 최적화하는 전통적인 구조 해결 방법이다.
- 연관된 객체끼리 데이터를 공유하게 하면서 application의 메모리를 최소화하는 목적을 가지고 있다.
- 플라이웨이트의 데이터 공유 방식은 여러 비슷한 객체나 데이터 구조에서 공통으로 사용되는 부분만을 하나의 외부 객체로 내보내는 것으로 이루어진다.
  <br/>각 객체에 데이터를 저장하기보다는 하난의 의존 외부 데이터에 모아서 저장할 수 있다.

#### 사용법
- 플라이웨이트 패턴을 사용하는 두 가지 방법
  1. 데이터 레이어에서 메모리에 저장된 수많은 비슷한 객체 사이로 데이터를 공유
  2. DOM 레이어에서 비슷한 동작을 하는 이벤트 핸들러를 모든 자식 요소에 등록하기보다는 부모 요소 같은 중앙 이벤트 관리자에게 맡기는 방법
    <br/> <b>참조* - 이벤트 위임(Event Delegation)</b>

#### 데이터 공유
- 전통적으로 플라이웨이트 패턴은 데이터 레이어에서 많이 사용되었기 때문에 이부분을 먼저 살펴본다.
- 플라이웨이트 패턴에는 두 가지 개념이 있다. ```내재적(intrinsic)``` 상태와 ```외재적(extrinsic)``` 상태
- <b>내재적 정보는 객체의 내부 메서드에 필요한 것이며, 없으면 절대로 동작하지 않는 것</b>
- <b>외재적 정보는 제거되어 외부에 저장될 수 있는 것</b>
- 같은 내재적 정보를 지닌 객체를 팩토리 메서드를 사용해 만들어진 하나의 공유된 객체로 대체할 수 있고, 이를 통해 저장된 내부 데이터의 양을 상당히 줄일 수 있다.
- 공통 부분으로 인스턴스화된 객체를 재사용하면 되기 때문에 객체의 내재적 정보가 다른 경우에만 새로운 객체 복사본을 생성하면 된다.
- 외재적 정보를 다룰 때에는 따로 관리자를 사용, 관리자는 다양한 방법으로 구현할 수 있지만.. 한 가지 방법은 플라이웨이트 객체와 내재적 상태를 보관하는 중앙 데이터베이스를 관리자로 사용하는 것

#### 전통적인 플라이웨이트 구현 방법
- 플라이웨이트: 외부의 상태를 받아 작동할 수 있게 하는 인터페이스
- 구체적 플라이웨이트: 플라이웨이트 인터페이스를 실제로 구현하고 내부 상태를 저장, 또한 다양한 컨텍스트 사이에서 공유될 수 있어야 하며 외부 상태를 조작할 수 있어야함
- 플라이웨이트 팩토리: 플라이웨이트 객체를 생성하고 관리

```jsx
/** 
* 예제 코드를 실행하면 Uncaught TypeError: Cannot assign to read only property 'prototype' of ${해당객체} 에러가 발생하는데,
* 이는 prototype 객체의 propertyDescriptor 객체의 writable 속성값이 false로 되어 있기 때문..(물론 configurable 속성값 또한 false)
*/

/**@description 인터페이스 구현을 시뮬레이션하기 위한 유틸리티 클래스 */
class InterfaceImplemetation {
  static implementsFor(superclassOrInterface) {
    if (superclassOrInterface instanceof Function) {
      this.prototype = Object.create(superclassOrInterface.prototype);
      this.prototype.constructor = this;
      this.prototype.parent = superclassOrInterface.prototype;
    } else {
      this.prototype = Object.create(superclassOrInterface);
      this.prototype.constructor = this;
      this.prototype.parent = superclassOrInterface;
    }
    return this;
  }
}

/* CoffeeOrder 인터페이스 */
const CoffeeOrder = {
  serveCoffee(context) {},
  getFlavor() {},
};

class CoffeeFlavor extends InterfaceImplemetation {
  constructor(newFlavor) {
    super();
    this.flavor = newFlavor;
  }

  getFlavor() {
    return this.flavor;
  }

  serveCoffee(context) {
    console.log(`Serving Coffee flavor ${this.flavor} to table ${context.getTable()}`);
  }
}

/* CoffeeOrder 인터페이스 구현 */
CoffeeFlavor.implementsFor(CoffeeOrder);

const CoffeeOrderContext = (tableNum) => ({
  getTable() {
    return tableNum;
  },
});

class CoffeeFlavorFactory {
  constructor() {
    this.flavors = {};
    this.length = 0;
  }

  getCoffeeFlavor(flavorName) {
    let flavor = this.flavors[flavorName];

    if (!flavor) {
      flavor = new CoffeeFlavor(flavorName);
      this.flavors[flavorName] = flavor;
      this.length++;
    }
    return flavor;
  }

  getTotalCoffeeFlavorsMade() {
    return this.length;
  }
}

const testFlyweight = () => {
  const flavors = [];
  const tables = [];
  let ordersMade = 0;
  const flavorFactory = new CoffeeFlavorFactory();

  function takeOrders(flavorsIn, table) {
    flavors.push(flavorFactory.getCoffeeFlavor(flavorsIn));
    tables.push(CoffeeOrderContext(table));
    ordersMade++;
  }

  takeOrders('Cappuccino', 2);

  for (let i = 0; i < ordersMade; i++) {
    flavors[i].serveCoffee(tables[i]);
  }

  console.info(`total CoffeeFlavor objects made: 
    ${flavorFactory.getTotalCoffeeFlavorsMade()}  
  `);
};

testFlyweight();

```



## 더 알아보기

### 💥함수 본문에서의 this 값 바인딩
- <b>단순 호출</b>: 엄격모드에서는 ```undefined```, 아니라면 전역 객체
- <b>메서드 호출 ```obj.fn()```</b>: this는 메서드를 호출한 객체 
- <b>call,apply,bind</b>: 첫 번째 인수로 전달 받은 값, 화살표 함수에는 적용X
- <b>생성자 호출</b>: this는 새 인스턴스 객체, 바운드(bind로 this를 전달받은) 함수라도 new 키워드가 우선적용
- <b>화살표 함수</b>: 자신의 **상위 렉시컬 스코프의 this**를 사용

- <b>이벤트 핸들러 함수 내부</b>
  - onclick 같은 이벤트 핸들러 프로퍼티나 addEventListener로 등록한 리스너 모두, 호출 시 this === event.currentTarget
  - 화살표 함수는 예외, **렉시컬 this**를 사용하므로 요소로 바인딩되지 않는다.