# Advanced React From Atlassian FE_Lead

## chapter 1. Intro to re-renders

바로 본론으로 들어가 보죠. 성능에 대한 이야기부터 시작합시다.
요즘 애플리케이션을 개발할 때 성능은 가장 중요한 주제 중 하나이며, 이 책 전체에서도 중심 테마로 다뤄집니다.

React와 React의 성능을 이야기할 때, 리렌더링(re-render) 이라는 개념과 그 영향력을 이해하는 것이 매우 중요합니다.
리렌더링이 어떻게 발생하는지, 애플리케이션 전반에 어떻게 전파되는지, 컴포넌트가 왜 리렌더링되는지, 그리고 애초에 왜 리렌더링이 필요한지를 알아야 합니다.

이 장에서는 이러한 개념들을 소개하며, 다음 몇 개의 장에서 더 깊이 있게 탐구할 것입니다.
그리고 좀 더 흥미롭게 만들기 위해, 이 내용을 조사(investigation) 형식으로 풀어보려 합니다.
실제 앱에서 매우 흔하게 발생하는 성능 문제를 하나 소개하고, 그 문제로 인해 어떤 일이 벌어지는지, 그리고 아주 단순한 컴포지션 기법으로 그것을 어떻게 해결할 수 있는지를 살펴보겠습니다.

이 과정을 통해 여러분은 다음과 같은 내용을 배우게 될 것입니다:

- 리렌더링이란 무엇이며, 왜 필요한가

- 모든 리렌더링의 출발점은 어디인가

- 리액트는 리렌더링을 어떻게 애플리케이션 전반에 전파하는가

- "리렌더링에 대한 큰 오해", 그리고 단순히 props가 바뀌는 것은 실제로 큰 의미가 없는 이유

- 성능 향상을 위한 "상태를 하위로 내려보내기(moving state down)" 기법

- 훅(hook)이 리렌더링 측면에서 왜 위험할 수 있는지

### 문제 상황
당신이 대규모이고 복잡하며 성능에 매우 민감한 앱을 인수받은 개발자라고 상상해보세요.
그 안에서는 수많은 일이 일어나고 있고, 수년에 걸쳐 여러 개발자들이 손을 댔으며, 지금은 수백만 명의 사용자가 이 앱을 사용하고 있습니다.

당신이 맡은 첫 번째 업무는 앱 상단에 아주 단순한 버튼 하나를 추가해서 모달 다이얼로그를 띄우는 기능을 구현하는 것입니다.

당신은 코드를 살펴보고, 모달 다이얼로그를 띄워야 할 위치를 찾습니다.

```jsx
const App = () => {
  // 여기에 많은 코드가 존재함
  return (
    <div className="layout">
      {/* 버튼은 아마 여기 어딘가에 추가해야 함 */}
      <VerySlowComponent />

      <BunchOfStuff />
      <OtherStuffAlsoComplicated />
    </div>
  );
};
```
그래서 버튼과 모달을 구현합니다. 이 작업은 꽤 간단해 보입니다. 우리가 이미 수백 번 해봤던 방식이죠

```jsx
const App = () => {
  // 상태 추가
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="layout">
      {/* 버튼 추가 */}
      <Button onClick={() => setIsOpen(true)}>
        Open dialog
      </Button>

      {/* 모달 다이얼로그 추가 */}
      {isOpen ? (
        <ModalDialog onClose={() => setIsOpen(false)} />
      ) : null}

      <VerySlowComponent />
      <BunchOfStuff />
      <OtherStuffAlsoComplicated />
    </div>
  );
};
```
버튼을 누르면 상태를 true로 설정하고, 상태가 true일 때만 모달 다이얼로그가 렌더링됩니다. 아주 흔한 패턴입니다.

앱을 실행하고 버튼을 눌러 보았더니...
문제가 발생합니다.
단순한 다이얼로그가 뜨는 데 거의 1초나 걸립니다!

React 성능 최적화에 경험이 있는 사람들은 이렇게 말할지도 모릅니다.
"아, 물론이지! 지금 앱 전체를 다시 렌더링하고 있으니, 모든 것을 React.memo로 감싸고 useCallback 훅을 사용해서 막아야 해."
기술적으로 보면 이는 맞는 말입니다. 하지만 너무 서두르지는 마세요.
이 상황에서는 메모이제이션(Memoization)은 완전히 불필요하며, 오히려 해가 될 수 있습니다.
더 효율적인 방법이 있으니까요.

그렇지만 먼저, 여기서 정확히 어떤 일이 일어나고 있는지 그리고 왜 그런지에 대해 살펴보도록 하겠습니다.

### State update, nested components, and re-renders
처음부터 시작해 봅시다. 리액트 컴포넌트의 생명주기(life cycle)와 성능을 논할 때 우리가 중요하게 다뤄야 할 주요 단계들입니다. 여기에는 마운트(mounting), 언마운트(unmounting), 그리고 **리렌더링(re-rendering)**이 포함됩니다.

1. 마운트 (Mounting) <br>
   컴포넌트가 화면에 처음 나타날 때를 마운트라고 부릅니다.
   이 시점은 리액트가 해당 컴포넌트의 인스턴스를 처음으로 생성하고, 상태(state)를 초기화하며, 훅(hook)을 실행하고, DOM에 요소를 추가하는 단계입니다.
   결과적으로, 이 컴포넌트에 렌더링된 내용이 화면에 보이게 됩니다.

2. 언마운트 (Unmounting) <br>
   언마운트는 리액트가 해당 컴포넌트가 더 이상 필요하지 않다고 판단했을 때 발생합니다.
   이 단계에서는 리액트가 마지막 정리(clean-up)를 수행하며, 컴포넌트 인스턴스와 상태(state) 같은 연관된 모든 데이터를 제거하고, 최종적으로 DOM에서 관련 요소를 삭제합니다.

3. 리렌더링 (Re-rendering) <br>
   리렌더링은 기존에 존재하는 컴포넌트에 새로운 정보를 업데이트하는 과정입니다.
   마운트에 비해 리렌더링은 상대적으로 가벼운 작업입니다. 리액트는 이미 존재하는 인스턴스를 재활용하고, 훅(hooks)을 실행하며 필요한 계산을 수행한 뒤, 새로운 속성으로 DOM 요소를 업데이트합니다.

상태(state)와 리렌더링
리렌더링은 **상태(state)**에서 시작됩니다.
리액트에서 useState, useReducer와 같은 훅을 사용하거나, Redux와 같은 외부 상태 관리 라이브러리를 사용하는 경우, 우리는 컴포넌트에 상호작용성을 추가합니다.
이제 컴포넌트는 생명주기 동안 유지되는 데이터를 가지게 됩니다.
사용자가 버튼을 클릭하거나 외부 데이터가 들어오는 등의 상호작용이 발생하면, 우리는 새로운 데이터로 상태를 업데이트하게 됩니다.

리렌더링은 리액트에서 가장 중요한 작업 중 하나입니다.
리액트는 컴포넌트를 새로운 데이터로 업데이트하며, 해당 데이터에 의존하는 모든 훅을 트리거합니다.
리렌더링이 없다면 리액트에서 데이터 업데이트가 이루어지지 않으며, 결과적으로 앱은 완전히 정적인 상태가 될 것입니다. 이처럼 상태 업데이트는 리액트 앱에서 모든 리렌더링의 근본적인 원천입니다.

예를 들어, 우리가 처음 생성한 앱을 사례로 든다면 이런 과정들이 어떻게 작동하는지 더 구체적으로 이해할 수 있을 것입니다.

```jsx
const App = () => {
  const [isOpen, setIsOpen] = useState(false);
  
  return (
    <Button onClick={() => setIsOpen(true)}>
        Open dialog
    </Button>
  );
};
```
1. 버튼 클릭과 상태 업데이트 <br>
사용자가 버튼을 클릭하면 setIsOpen 설정 함수(setter function)가 실행됩니다.
여기서 isOpen 상태는 새로운 값으로 업데이트됩니다. 예를 들어, false에서 true로 변경됩니다.
이렇게 상태가 업데이트되면, 해당 상태를 가지고 있는 App 컴포넌트가 다시 리렌더링됩니다.
2. React의 상태 전달과 리렌더링 <br>
상태가 업데이트된 후, App 컴포넌트가 리렌더링되면서 새로운 데이터가 이 컴포넌트에 의존하는 다른 하위 컴포넌트들로 전달됩니다.
React는 이를 자동으로 처리합니다.
우선 App 컴포넌트가 렌더링하는 하위 컴포넌트들을 찾아서 리렌더링합니다.
이어서 하위 컴포넌트 중 네스팅(nesting)된 컴포넌트들이 있다면, 그 컴포넌트들도 다시 리렌더링하며, 이 과정을 마지막 컴포넌트까지 반복합니다.
3. 트리(Tree) 구조로 이해하기 <br>
일반적인 React 앱을 트리 구조로 상상해보면, 상태 업데이트가 발생한 지점부터 트리 아래로 내려가는 모든 컴포넌트들이 리렌더링됩니다.
즉, 상태 업데이트가 시작된 지점 이후의 모든 하위 컴포넌트들이 리렌더링 대상으로 포함되는 것입니다.

================ 15 PAGE 부터 시작해야함 ================