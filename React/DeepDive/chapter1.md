## 1. 리액트 개발을 위해 꼭 알아야 할 자바스크립트 ( 목차 + 28P )

### 1.1 자바스크립트의 동등 비교

- 리액트 함수 컴포넌트와 훅을 반복적으로 작성하다 보면 의존성 배열에 대해 고민해 본 적이 있을 것이다. 보통은 리액트에서 제공하는 eslint-react-config 에 선언되어 있는 react-hooks/exhaustive-deps 의 도움을 받아 해당 배열을 채우곤 하는데, 실제로 이것이 어떤 식으로 작동하는지, 또한 왜 이러한 변수들을 넣어야 하는지 이해하지 못하는 경우가 많다. 또 리액트 컴포넌트의 렌더링이 발생하는 이유 중 하나가 바로 props 의 동등 비교에 따른 결과다. 그리고 이 props 의 동등 비교는 객체의 얕은 비교를 기반으로 이루어지는데, 이 얕은 비교가 리액트에서 어떻게 작동하는지 이해하지 못하면 렌더링 최적화에 어려움을 겪을 가능성이 크다.

- 리액트의 가상 DOM 과 실제 DOM 의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다. 자바스크립트의 이러한 동등 비교는 어떻게 수행되는지, 또 이를 리액트에서 어떻게 활용하고 있는지 살펴보자.

#### 1.1.1 자바스크립트의 데이터 타입

- Primitive type (원시 타입) - typeof 키워드드로 타입 검사시 사용 가능

  - boolean, null, undefined, number, string, symbol, bigint
  - ```jsx
    const isUndefined = undefined;
    const isString = "str";

    console.log(typeof isUndefined === "undefined"); // true
    console.log(typeof isString === "number"); // false
    ```

- Object/reference type (객체/참조 타입)

  - object

- 원시타입

  - 자바스크립트에서 원시 타입이란 객체가 아닌 다른 모든 타입을 의미, 객체가 아니므로 이러한 타입들은 메서드를 가지지 않는다. (\*래퍼 객체 개념...)
  - ES2022 와 같은 최신 자바스크립트에서는 총 7개의 원시 타입이 있다.

- undefined

  - 선언한 이후 값을 할당하지 않은 변수 또는 값이 주어지지 않은 인수(parameter)에 자동으로 할당되는 값이다.
  - 후술할 원시 값 중 null 과 undefined 는 오직 각각 null 과 undefined라는 값만 가질 수 있으며, 그 밖의 타입은 가질 수 있는 값이 두개 이상 존재한다.

- null

  - 아직 값이 없거나 비어 있는 값을 표현할 때 사용한다.

  - ```jsx
    typeof null === "object"; // true?
    ```
  - 특별한 점 하나는 다른 원시값과 다르게 typeof 로 null을 확인했을 때 null 타입이 아닌 "object"라는 결과가 반환된다는 것이다.
  - undefined는 '선언됐지만 할당되지 않은 값'이고, null은 '명시적으로 비어 있음을 나타내는 값'으로 사용하는 것이 일반적이다.

- Symbol
  - ES6 에서 새롭게 추가된 7번째 타입으로, 중복되지 않는 어떠한 고유한 값을 나타내기 위해 만들어졌다. 심벌은 심벌 함수를 이용해서만 만들 수 있다.
  - ```jsx
    // Symbol 함수에 같은 인수를 넘겨주더라도 이는 동일한 값으로 인정되지 않는다.
    // symbol 함수 내부에 넘겨주는 값은 Symbol 생성에 영향을 미치지 않는다 (Symbol.for 제외)
    const key = Symbol("key");
    const key2 = Symbol("key");
    ```

#### 1.1.2 값을 저장하는 방식의 차이

- 원시 타입과 객체 타입의 가장 큰 차이점이라고 한다면, 바로 값을 저장하는 방식의 차이다. </br>
  이 값을 저장하는 방식의 차이가 동등 비교를 할 때 차이를 만드는 원인이 된다.

- 먼저 원시 타입은 불변 형태의 값으로 저장되고, 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장된다.

```jsx
let h = "hello world";
let h2 = "hello world";
console.log(h === h2); // true
```

- 반면 객체는 프로퍼티를 추가, 삭제, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.

```jsx
let h = {
  greet: "hello world",
};

let h2 = {
  greet: "hello world",
};
// 참조 타입인 두 객체를 비교하면 false
console.log(h === h2); // false
// 원시 값인 내부 greet 속성값을 비교하면 true
console.log(h.greet === h2.greet); // true
```

- 객체는 값을 저장하는 것이 아니라 참조를 저장하기 때문에 앞서 동일하게 선언했던 객체라 하더라도 저장하는 순간 다른 참조를 바라보기 때문에 false 를 반환한다.

#### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is

- 자바스크립트에서는 비교를 위한 또 한 가지 방법을 제공하는데, 바로 Object.is 다. <br/>
  Object.is 가 == 나 === 와 다른 점은 다음과 같다.

- == vs Object.is

  - == 비교는 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형 변환(type casting)을 한 후에 비교한다. 하지만 Object.is 는 이러한 작업을 하지 않는다.

- === vs Object.is

  - 이 방식에도 차이가 있다. 예제를 보면 알 수 있듯, Object.is 가 좀 더 개발자가 기대하는 방식으로 정확히 비교한다.

  - ```jsx
    -0 === +0; // true
    Object.is(-0, +0); // false

    Number.NaN === NaN; // false
    Object.is(Number.NaN, NaN); // true

    NaN === 0 / 0; //false
    Object.is(NaN, 0 / 0); // true
    ```

  - 이렇듯 == 과 ===가 만족하지 못하는 몇 가지 특이 케이스를 추가하기 위해, Object.is가 나름의 알고리즘으로 작동하는 것을 알 수 있다. 한 가지 주의해야 할 점은, Object.is를 사용한다 하더라도 객체 비교에는 별 차이가 없다는 것이다.
  - ```jsx
    Object.is({}, {}); // false

    const a = { hello: "hi" };
    const b = a;

    Object.is(a, b); //true
    a === b; //true
    ```

  - Object.is 는 ES6 에서 새로이 도입된 비교 문법으로, 위와 같이 몇 가지 특별한 사항에서 동등 비교 === 가 가지는 한계를 극복하기 위해 만들어졌다. 그러나 여전히 객체 간 비교에 있어서는 자바스크립트의 특징으로 인해 ===와 동일하게 동작하는 것을 알 수 있다.

#### 1.1.4 리액트에서의 동등 비교

- 그렇다면 리액트에서는 동등 비교가 어떻게 이루어질까? 리액트에서 사용하는 동등 비교는 Object.is 이다. ES6 에서 제공하는 기능이기 때문에 리액트에서는 이를 구현한 폴리필(polyfill)을 함께 사용한다.

```tsx
function is(x: any, y: any) {
  return (
    // eslint-disable-line no-self-compare
    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y)
  );
}
// 런타임에 Object.is 가 있다면 그것을 사용하고, 아니라면 위에서 정의한 함수를 사용
const objectIs: (x: any, y: any) => boolean =
  typeof Object.is === "function" ? Object.is : is;

export default objectIs;
```

- 리액트에서는 이 Object.is 를 기반으로 동등 비교를 하는 shallowEqual 이라는 함수를 만들어 사용한다. 이 shallowEqual은 의존성 비교 등 리액트의 동등 비교가 필요한 다양한 곳에서 사용된다.

```tsx
const { hasOwnProperty, is, keys } = Object;

function shallowEqual(objA: mixed, objB: mixed): boolean {
  if (is(objA, objB)) {
    return true;
  }

  if (
    typeof objA !== "object" ||
    objA === null ||
    typeof objB !== "object" ||
    objB === null
  ) {
    return false;
  }
  // 각 키 배열을 꺼낸다.
  const [keysA, keysB] = [keys(objA), keys(objB)];
  // 배열의 길이가 다르다면 false
  if (keysA.length !== keysB.length) {
    return false;
  }

  for (let i = 0; i < keysA.length; i++) {
    const currentKey = keysA[i];
    if (
      !hasOwnProperty.call(objB, currentKey) ||
      !is(objA[currentKey], objB[currentKey])
    ) {
      return false;
    }
  }
  return true;
}
```

- 리액트에서의 비교를 요약하자면 Object.is로 먼저 비교를 수행한 다음에 Object.is에서 수행하지 못하는 비교, 즉 객체 간 얕은 비교를 한번 더 수행하는 것을 알 수 있다. 객체 간 얕은 비교란 객체의 첫 번째 깊이에 존재하는 속성 값만 비교한다는 것을 의미한다.

- 이렇게 객체의 얕은 비교까지만 구현한 이유는 무엇일까? 먼저 리액트에서 사용하는 JSX props는 객체이고, 그리고 여기에 있는 props만 일차적으로 비교하면 되기 때문이다. 예제 코드를 보자

```tsx
type Props = {
  hello: string;
};

function HelloComponent(props: Props) {
  return <h1>{props.hello}</h1>;
}

// ...

function App() {
  return <HelloComponent hello={"hi"} />;
}
```

- 위 코드에서 props 는 객체다. 그리고 기본적으로 리액트는 props 에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 일반적인 케이스에서는 얕은 비교로 충분하다. 이러한 특성을 안다면 props에 또 다른 객체를 넘겨준다면 리액트 렌더링이 예상치 못하게 동작한다는 것을 알 수 있다.

- props 가 깊어지는 경우, 한 객체 안에 또 다른 객체가 있을 경우 React.memo는 컴포넌트에 실제로 변경된 값이 없음에도 불구하고 메모이제이션된 컴포넌트를 반환하지 못한다.

### 1.2 함수

#### 1.2.1 함수란 무엇인가?

- 함수란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것을 의미한다.
- 리액트에서 컴포넌트를 만드는 함수도 이러한 기초적인 형태를 따르는 것을 알 수 있다.

```jsx
function Component(props) {
  return <div>{props.hello}</div>;
}
```

- Component 라고 하는 함수를 선언하고 매개변수로는 일반적으로 props라고 부르는 단일 객체를 받으며 return 문으로 JSX를 반환한다. 일반적인 함수와의 차이점이라고 한다면, 자바스크립트에서는 Component(props) 형태로 호출하지만, 리액트에서의 함수 컴포넌트는 단일 Props 별로 받거나, 모든 props를 전개 연산자로 받는다는 차이가 있다는 것이다. 그리고 이러한 JSX 형태 외에도 일반적인 자바스크립트 문법으로 함수 컴포넌트를 호출하는 것도 가능하다.

#### 1.2.2 함수를 정의하는 4가지 방법

- 1. 함수 선언문 : 함수 선언문은 표현식이 아닌 일반 문(statement)으로 분류된다. 표현식이란 무언가 값을 산출하는 구문을 의미한다. 즉, 앞선 함수 선언으로는 어떠한 값도 표현되지 않았으므로 표현식이 아닌 문으로 분류된다.

```jsx
function add(a, b) {
  return a + b;
}
```

- 2. 함수 표현식 : 먼저 '일급 객체'라는 개념을 알고 있어야 한다. 프로그래밍 세계에서 일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다. 자바스크립트에서 함수는 일급 객체다. 함수는 다른 함수의 매개변수가 될 수도 있고, 반환값이 될 수도 있으며, 앞에서 본 것처럼 할당도 가능하므로 일급 객체가 되기 위한 조건을 모두 갖추고 있다.

- 함수 표현식에서는 할당하려는 함수의 이름을 생략하는 것이 일반적이다. 그 이유는 코드를 봤을 때 혼란을 방지하기 위함이다.

```jsx
const sum = function add(a, b) {
  console.log(arguments.callee.name);
  return a + b;
};

sum(10, 24); // 34

add(10, 24); // uncaught referenceError: add is not defined
```

- 위 예제를 살펴보면 실제 함수를 호출하기 위해 사용된 것은 sum 임을 알 수 있다. 그리고 add는 실제 함수 내부에서만 유효한 식별자일 뿐, 함수를 외부에서 호출하는 데에는 사용할 수 없는 식별자다. 따라서 함수 표현식에서 함수에 이름을 주는 것은 함수 호출에 도움이 전혀 안 되는 요소임을 알 수 있다.

- 3. Function 생성자

```jsx
const add = new Function("a", "b", "return a + b");
add(10, 24); // 34
```

- 생성자 방식으로 함수를 만들게 되면 함수의 클로저 또한 생성되지 않는다. 생성자 함수 방식으로 함수를 만드는 것은 권장되지 않는다. eval 만큼이나 실제 코딩에서 사용되지 않는 방법이라고 볼 수 있다.

- 4. 화살표 함수
- ES6에서 새롭게 추가된 함수 생성 방식으로, function 키워드 대신 => 라는 화살표를 이용하여 함수를 만든다.

```jsx
const add = (a, b) => {
  return a + b;
};

const add = (a, b) => a + b;
```

- 화살표 함수는 앞서 언급한 함수 생성 방식들과 몇 가지 큰 차이점이 있다. 이에 대해서 하나씩 살펴보자.

- 먼저 화살표 함수에서는 constructor를 사용할 수 없다. 즉, 생성자 함수로 화살표 함수를 사용하는 것은 불가능하다.

```jsx
const Car = (name) => {
  this.name = name;
};
const myCar = new Car("차"); // Uncaught TypeError: Car is not a constructor
```

- 그리고 화살표 함수에서는 arguments 객체가 존재하지 않는다.
- 화살표 함수와 일반 함수의 가장 큰 차이점은 바로 this 바인딩이다. 먼저 this 란 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다. 이 this는 화살표 함수 이전까지는 함수를 정의할 때 결정되는 것이 아니라, 함수가 어떻게 호출되느냐에 따라 동적으로 결정된다. 만약 함수가 일반 함수로서 호출된다면, 그 내부의 this 는 전역 객체를 가리키게 된다.
- 그러나 화살표 함수는 함수 자체의 바인딩을 가지지 않는다. 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따르게 된다.

#### 1.2.3 다양한 함수 살펴보기

- 즉시 실행 함수 : 함수를 정의하고 그 순간 즉시 실행되는 함수를 의미

```jsx
(function (a, b) {
  return a + b;
})(10, 24); //34

((a, b) => {
  return a + b;
})(10, 24); //34
```

- 고차 함수 : JS의 함수가 일급 객체라는 특징을 활용하면 함수를 인수로 받거나 결과로 새로운 함수를 반환시킬 수 있다. 이런 역할을 하는 함수를 고차 함수라고 한다.

```jsx
const doubledArray = [1, 2, 3].map((item) => item * 2);

doubledArray; // [2,4,6]

const add = function (a) {
  return (b) => {
    return a + b;
  };
};
add(1)(3); //4
```

- 이러한 특징을 활용해 추후에 다룰 함수 컴포넌트를 인수로 받아 새로운 함수 컴포넌트를 반환하는 고차 함수를 만들 수도 있다. 이런 컴포넌트를 고차 함수와 유사하게 고차 컴포넌트라고 부르는드ㅔ, 고차 함수 컴포넌트를 만들면 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있어 효율적으로 리팩터링할 수 있다.

#### 1.2.4 함수를 만들 때 주의해야 할 사항

- 1. 함수의 부수 효과를 최대한 억제하라

  - 부수 효과(side-effect) : 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것을 의미
  - 리액트의 관점에서 본다면 부수 효과를 처리하는 훅인 useEffect의 작동을 최소화하는 것이 그 일환이라 할 수 있다.

- 2. 가능한 한 함수를 작게 만들어라
  - 하나의 함수에서 너무나 많은 일을 하지 않게 하라
- 3. 누구나 이해할 수 있는 이름을 붙여라

### 1.3 클래스

#### 1.3.1 클래스란 무엇인가?

- 특정한 객체를 만들기 위한 일종의 템플릿과 같은 개념으로 볼 수 있다. 즉, 특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것이 바로 클래스다. 클래스 문법이 나오기 이전에는 클래스라는 개념이 없어 객체를 만드는 템플릿 같은 역할을 함수가 도맡아 했었다. 반대로 말하자면, 우리가 자바스크립트에서 클래스로 하는 모든 것들을 함수로도 동일하게 표현할 수 있다.

  - constructor
  - property
  - getter & setter
  - instance method
  - static method

- \_\_proto\_\_ 는 가급적 사용해서는 안되는 코드이다. Object.getPrototypeOf 를 사용하는 것이 권장된다.

#### 1.3.2 클래스와 함수의 관계

- 클래스가 작동하는 방식은 자바스크립트의 프로토타입을 활용하는 것
- 클래스 작동을 생성자 함수로 매우 유사하게 재현 가능하다. 즉, 클래스는 객체지향 언어를 사용하던 다른 프로그래머가 좀 더 자바스크립트에 접근하기 쉽게 만들어주는, 일종의 문법적 설탕의 역할을 한다고 볼 수 있다.

### 1.4 클로저

- 함수 컴포넌트의 구조와 작동 방식, 훅의 원리, 의존성 배열 등 함수 컴포넌트의 대부분의 기술이 모두 클로저에 의존하고 있기 때문에 함수 컴포넌트의 작성을 위해서는 클로저에 대해 이해하는 것이 필수다.

#### 1.4.1 클로저의 정의

- MDN : "클로저는 함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합"

```jsx
function add() {
  const a = 10;

  function innerAdd() {
    const b = 20;
    console.log(a + b);
  }

  innerAdd(); // 30
}

add();
```

- 앞에서 이야기한 "선언된 어휘적 환경"이라는 것은, 변수가 코드 내부에서 어디서 선언됐는지를 말하는 것이다. 이는 앞서 이야기한, 호출되는 방식에 따라 동적으로 결정되는 this 와는 다르게 코드가 작성된 순간에 정적으로 결정된다. 클로저는 이러한 어휘적 환경을 조합해 코딩하는 기법이다.

#### 1.4.2 변수의 유효 범위, 스코프

- 앞서 클로저를 이해하기 위해서는 변수의 유효 범위에 따라서 어휘적 환경이 결정된다고 언급했다. 이러한 변수의 유효 범위를 스코프(scope)라고 하는데, 자바스크립트에는 다양한 스코프가 있다.

- 전역 스코프 : 전역 레벨에 선언하는 것을 전역 스코프라고 한다. 이 스코프에서 변수를 선언하면 어디서든 호출할 수 있게 된다. 전역 객체 ( 브라우저-(window), Node.js-(global) )의 속성으로 바인딩 된다.

- 함수 스코프 : JS는 기본적으로 함수 레벨 스코프를 따른다. 즉, {} 블록이 스코프 범위를 결정하지 않는다.

```jsx
if (true) {
  var global = "global scope";
}
console.log(global); // 'global scope'
console.log(global === window.global); // true
```

```jsx
var x = 10;

function foo() {
  var x = 100;
  console.log(x); //100

  function bar() {
    var x = 1000;
    console.log(x); // 1000;
  }

  bar();
}

console.log(x); //10;
foo();
```

- JS 에서 스코프는, 일단 가장 가까운 스코프에서 변수가 존재하는지를 확인해 보는데, 이러한 사실을 알고 있다면 위 예제에서 x가 어디에 선언되어 있는지에 따라 값이 달라질 수 있음을 쉽게 확인할 수 있다.

#### 1.4.3 클로저의 활용

- 전역 스코프는 어디서든 원하는 값을 꺼내올 수 있다는 장점이 있지만, 반대로 이야기하면 누구든 접근할 수 있고 수정할 수 있다는 뜻도 된다.
- 만약 리액트이 useState 변수가 전역 레벨에 저장되어 있다면? Js를 조금만 아는 사람이라면 누구나 리액트 어플리케이션을 쉽게 망가뜨릴 수 있게 된다. 따라서 리액트가 관리하는 내부 상태 값은 리액트가 별도로 관리하는 클로저 내부에서만 접근할 수 있다.

- 리액트에서의 클로저
  - 클로저의 원리를 사용하고 있는 대표적인 것 중 하나가 바로 useState 이다.

```jsx
function Component() {
  const [state, setState] = useState();

  function handleClick() {
    // useState 호출은 위에서 끝났지만,
    // setState는 계속 내부의 최신값(prev)을 알고 있다.
    // 이는 클로저를 활용했기 때문에 가능하다.
    setState((prev) => prev + 1);
  }

  // ...
}
```

- useState 함수의 호출은 Component 내부 첫 줄에서 종료되었는데, setState는 useState 내부의 최신 값을 어떻게 계속해서 확인할 수 있을까?? 그것은 바로 클로저가 useState 내부에서 활용되었기 때문이다.
  외부 함수(useState)가 반환한 내부 함수(setState)는 외부 함수(useState)의 호출이 끝났음에도 자신이 선언된 외부 함수가 선언된 환경(state가 저장되어 있는 어딘가)을 기억하기 때문에 계속해서 state 값을 사용할 수 있는 것이다.

#### 1.4.4 주의할 점

- 클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가 비용이 발생한다.

### 1.5 이벤트 루프와 비동기 통신의 이해

- 프로세스 (process) : 프로그램을 구동해 프로그램의 상태가 메모리상에서 실행되는 작업 단위
  - 즉, 하나의 프로그램 실행은 하나의 프로세스를 가지고 그 프로세스 내부에서 모든 작업이 처리되는 것을 의미했다. 그러나 소프트웨어가 점차 복잡해지며 하나의 프로그램에서 여러 개의 복잡한 작업을 동시에 수행할 필요성이 대두되었다. 하지만 하나의 프로그램에는 하나의 프로세스만이 할당되므로 이러한 작업을 수행하기 어려웠는데, 그래서 탄생한 더 작은 실행 단위가 바로 스레드(thread)이다.
  - 하나의 프로세스내에서 여러개의 스레드를 만들 수 있고, 스레드끼리는 메모리를 공유할 수 있어 여러 가지 작업을 동시에 수행할 수 있다.

#### 1.5.1 싱글 스레드 자바 스크립트

#### 1.5.2 이벤트 루프란?

- 이벤트 루프는 ECMAScript, 즉 자바스크립트 표준에 나와 있는 내용은 아니다. 즉, 이벤트 루프란 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치라고 볼 수 있다.

- 호출 스택과 이벤트 루프
  - 호출 스택은 JS에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택이다. 이 호출 스택이 비어 있는지 여부를 확인하는 것이 바로 이벤트 루프다. 이벤트 루프는 단순히 이벤트 루프만의 단일 스레드 내부에서 이 호출 스택 내부에 수행해야 할 작업이 있는지 확인하고, 수행해야 할 코드가 있다면 자바스크립트 엔진을 이용해 실행한다. 한 가지 알아둘 점은 '코드를 실행하는 것'과 '호출 스택이 비어 있는지 확인하는 것'모두가 단일 스레드에서 발생한다는 점이다. 즉, 두 작업은 동시에 일어날 수 없으며 한 스레드에서 순차적으로 일어난다.
- 태스크 큐
  - 태스크 큐란 실행해야 할 태스크의 집합을 의미한다. 이벤트 루프는 이러한 태스크 큐를 한 개 이상 가지고 있다. 그리고 이름과는 다르게 태스크 큐는 자료구조의 큐(queue)가 아니고 set 형태를 띠고 있다. 그 이유는 선택된 큐 중에서 실행 가능한 가장 오래된 태스크를 가져와야 하기 때문이다. 태스크 큐에서 의미하는 '실행해야 할 태스크'라는 것은 비동기 함수의 콜백 함수나 이벤트 핸들러 등을 의미한다.
- 즉, 이벤트 루프의 역할은 호출 스택에 실행 중인 코드가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인하는 역할을 한다. 호출 스택이 비었다면 태스크 큐에 대기 중인 작업이 있는지 확인하고, 이 작업을 실행 가능한 오래된 것부터 순차적으로 꺼내와서 실행하게 된다. 이 작업 또한 마찬가지로 태스크 큐가 빌 때까지 이루어진다.

- 그렇다면 저 비동기 함수는 누가 수행할까? .. 이러한 작업들은 모두 JS 코드가 동기식으로 실행되는 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에서 수행된다. 이 별도의 스레드에서 태스크 큐에 작업을 할당해 처리하는 것은 브라우저나 Node.js의 역할이다. 즉, JS 코드 실행은 싱글 스레드에서 이루어지지만 이러한 외부 Web API 등은 모두 JS 코드 외부에서 실행되고 콜백이 태스크 큐로 들어가는 것이다. 이벤트 루프는 호출 스택이 비고, 콜백이 실행 가능한 때가 오면 이것을 꺼내서 수행하는 역할을 하는 것이다.

#### 1.5.3 태스크 큐와 마이크로 태스크 큐

- 태스크 큐와 다르게, 마이크로 태스크 큐라는 것도 있다. 이벤트 루프는 하나의 마이크로 태스크 큐를 가지고 있는데, 기존의 태스크 큐와는 다른 태스크를 처리한다. 대표적으로 Promise 가 있다. 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 가진다. 즉, setTimeout 과 setInterval은 Promise 보다 늦게 실행된다.

```jsx
function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

setTimeout(foo, 0);

Promise.resolve().then(bar).then(baz);

// => bar baz foo
```

- 그렇다면 (브라우저)렌더링은 언제 실행될까? 태스크일까 마이크로 태스크 큐일까?
  태스크 큐를 실행하기에 앞서 먼저 마이크로 태스크 큐를 실행하고, 이 마이크로 태스크 큐를 실행한 뒤에 렌더링이 일어난다. 각 마이크로 태스크 큐 작업이 끝날 때마다 한 번씩 렌더링할 기회를 얻게 된다.
- requestAnimationFrame : 다음 리페인트 전에 콜백 함수 호출을 가능하게 하는 함수

### 1.6 리액트에서 자주 사용하는 자바스크립트 문법

#### 1.6.1 구조 분해 할당

#### 1.6.2 전개 구문

#### 1.6.3 객체 초기자

#### 1.6.4 Array 프로토 타입의 메서드: map, filter, reduce, forEach

#### 1.6.5 삼항 조건 연산자

#### 1.6.6 정리

### 1.7 선택이 아닌 필수, 타입스크립트

#### 1.7.1 타입스크립트란?

#### 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법

- any 대신 unknown을 사용하자 (<--> never)
  - unknown 은 any와는 다르게 값을 곧바로 사용하는 것이 불가하고, type narrowing 을 통하여 사용하도록 강제되기 때문에 더 안전하게 사용할 수 있다.
- 타입 가드를 적극 활용하자

  - intanceof 와 typeof
  - in : 주로 어떤 객체에 키가 존재하는지 확인하는 용도로 사용된다.
  - ```jsx
    const obj = {
      name: "obj",
    };

    console.log("name" in obj); // true
    console.log("key" in obj); // false
    ```

- 제네릭
  - 리액트에서 제네릭을 사용할 수 있는 코드를 손꼽는다면 가장 먼저 useState 를 떠올릴 수 있다.

```tsx
function Component() {
  const [state, setState] = useState<string>("");
}
```

- 인덱스 시그니처

```tsx
type Hello = {
  [key: string]: string;
};

// also
type Hello = Record<"hello" | "hi", "string">;

const hello: Hello = {
  hello: "str1",
  hi: "str2",
};

hello["hi"]; // str2
hello["안녕"]; //undefined
```

- Object.keys 는 string [] 타입을 반환 ( 덕 타이핑 문제 )
- TS의 Object.keys 에 대한 반환 타입을 string[] 대신 개발자가 단언한 타입으로 강제하는 방법
```tsx
// solution 1
(Object.keys(hello) as Array<keyof Hello>).map((key) => {
  const value = hello[key];
  return value;
});

// solution 2
Object.keys(hello).map((key) => {
  const value = hello[key as keyof Hello];
  return value;
});
```
- 이처럼 JS는 객체의 타입에 구애받지 않고 객체의 타입에 열려 있으므로 TS도 이러한 JS의 특징을 맞춰주어야 한다.
- 즉, TS는 이렇게 모든 키가 들어올 수 있는 가능성이 열려 있는 객체의 키에 포괄적으로 대응하기 위해 string[] 으로 타입을 제공하는 것

#### 1.7.3 타입스크립트 전환 가이드 (생략)
