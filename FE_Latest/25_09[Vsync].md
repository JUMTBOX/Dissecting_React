## Difference between requestAnimationFrame & scheduler.postTask with Vsync

### 1. 프레임 정렬

- CSS transition은 UserAgent 가 “애니메이션/렌더링 단계”에서 시간 기반으로 갱신합니다. <br> 선언만 하면 다음 프레임부터 보간이 시작되고, transform/opacity 등은 컴포지터 스레드에서 메인 스레드와 독립적으로 계속 진행될 수 있습니다.
- requestAnimationFrame은 “다음 페인트 직전”의 애니메이션 프레임 콜백 단계에 실행됩니다. 즉 rAF는 vsync에 정렬되며, 한 프레임 안에서 DOM 업데이트→페인트로 이어지게 설계되어 있습니다.
- scheduler.postTask(() => {}, {priority: "user-blocking"})은 “이벤트 루프의 일반 태스크”입니다. 우선순위는 큐 내 상대적 순서에만 영향이 있고 vsync에 붙여 주지 않습니다. 길게 실행되면 오히려 다음 프레임을 지연시킬 수 있습니다.

### 2. 스타일 변경의 처리 방식

- CSS transition은 “계산값이 변하면” UserAgent가 보간을 생성합니다. <br>같은 태스크 안에서 초기값과 최종값을 연달아 써버리면 변화가 병합되어 보간이 생기지 않을 수 있고, 보통 “프레임 경계”를 만드는 rAF·강제 리플로우 등을 섞어 시작 시점을 분리합니다.
- rAF는 그 경계를 보장해 주는 도구라 “초기 상태 적용 → rAF에서 최종 상태 적용” 패턴이 안정적입니다.
- postTask는 프레임 경계를 보장하지 않아 같은 턴에서 초기·최종 스타일이 합쳐지기 쉽고, 심하면 페인트를 늦춥니다. 우선순위를 올려도 이 특성은 바뀌지 않습니다.

### 3. 메인 스레드 점유와 끊김
- transition의 대상이 컴포지터 전용 속성(transform, opacity 등)이라면 메인 스레드가 바쁘더라도 계속 진행될 수 있어 프레임 드랍 내성이 큽니다. JS 구동(rAF·postTask)은 메인 스레드가 바쁘면 실행 자체가 밀립니다.

### Vsync (Vertical synchronization) 란?
- 디스플레이가 한 프레임을 화면에 그려내는 주기 ( 일반적으로 60Hz -> 16.6ms,  120Hz -> 8.3ms ) 와<br> 브라우저 렌더링 파이프라인을 맞추는 메커니즘


### 브라우저의 사이클
    1. 입력 처리 -> JS 실행 -> 스타일/레이아웃 계산
    2. 페인트 명령 생성 
    3. GPU/컴포지터가 실제 프레임을 화면에 전송

### "Vsync 에 정렬된다" 라는 의미
- #### requestAnimationFrame 같은 API가 디스플레이에 새 프레임이 그려지기 직전 시점에 콜백을 실행하도록 예약된다는 의미
  - 즉, 화면 리프레시 타이밍에 맞추어 DOM 변경을 적용하면 곧바로 그 다음 화면 출력에 반영된다.

- <h4> 반면 scheduler.postTask 는 이벤트 루프 내 태스크 큐에서 우선순위에 따라 실행될 뿐이고, 디스플레이 주기와 직접 동기화 되지 않는다. <br>
  그래서 같은 DOM 변경이라도 "프레임 경계"가 보장되지 않고, 변경이 같은 프레임 안에서 합쳐지거나 지연될 수 있다.</h4>

## 더 알아보기

### 브라우저 렌더링 단계 요약
    1. 자바스크립트 실행: DOM/CSSOM 변경
    2. 스타일 계산 & 레이아웃: 요소 위치·크기 계산
    3. 페인트(Paint): 각 요소를 비트맵으로 그림
    4. 합성(Compositing): 여러 레이어를 GPU에서 합쳐 최종 프레임 생성

### 💥 Compositor Thread
- 위의 "브라우저 렌더링 단계" 중 4단계를 GPU와 협력하여 처리 ( 1 ~3 단계는 브라우저 메인 스레드가 담당 )
- 웹 브라우저의 별도 스레드로서, 렌더링 엔진의 주요 작업인 렌더링과 별개로 작동하며 GPU를 활용하여 웹 페이지의 최종 이미지를 만드는 역할을 함 
- 이 스레드는 메인 스레드에서 생성된 레이어를 받아 화면에 표시할 최종 뷰로 합성하고, 스크롤, 애니메이션 등 사용자 인터랙션이 발생할 때 메인 스레드의 부하 없이 부드럽게 처리하는 데 기여하여 전체적인 브라우저 성능을 향상 시킨다. 

